# http://www.cnblogs.com/kuihua/p/5505621.html
# http://selenium-python.readthedocs.io/index.html
# 扩展作业

# 原版是1.11,书籍是1.7

yum install firefox
git version
pip3 -V
python3 -V

# python 3.4.2 -> django 1.7
# 版本间需要匹配 14年9月1.7

# sudo pip3 install django==1.7
# sudo pip3 install --upgrade selenium

pip install "django<1.12" "selenium<4"

使用功能测试协助安装Django
# 遵从测试山羊的教诲，没有测试什么也别做
vi functional_test.py
  from selenium import webdriver
  
  browser = webdriver.Firefox()
  browser.get('http://localhost:8000')
  
  assert 'Django' in browser.title 
python !$
# 基础测试的写法

# 让Django运行起来
mkdir tdd_django
django-admin.py startproject superlists .
#不加点会有2个类似的目录

python manage.py runserver
python functional_test.py

# 创建Git仓库
mv functional_test.py superlists/
cd superlists/
git init .

echo "db.sqlite3" >> .gitignore
echo "geckodriver.log" >> .gitignore
echo "virtualenv" >> .gitignore

git add .
git status

git rm -r --cached superlists/__pycache__
echo "__pycache__" >> .gitignore
echo "*.pyc" >> .gitignore

git add .gitignore
git commit



使用unittest模块扩展功能测试
  # 使用功能测试驱动开发一个最简可用的应用
python manage.py runserver
python functional_test.py

  # Python标准库中的unittest模块
assert'To-Do' in browser.title, "Browser title was " + browser.title
# 显示标题内容

vi functional_test.py
# 修改为类的形式 
# 继承测试类,test_开头,setUp,tearDown测试前后,self.xx断言,self.fail提示,__main__方法,

# https://docs.python.org/3/library/unittest.html  LiveServerTestCase

  # 隐式等待
# self.browser.implicitly_wait(3)
  # 显示未定义,待调整

  # 提交
git diff
git commit -a



使用单元测试测试简单的首页
  # 第一个Django应用，第一个单元测试
# 以应用的方式组织代码,一个项目中放多个应用
python manage.py startapp lists

  # 单元测试及其与功能测试的区别
# 功能测试,用户角度,外部
# 单元测试,开发角度,内部

# 先写功能,用户角度描述功能,功能测试失败后,编写代码让它通过
# 单元测试失败后,最少代码让其通过,再功能测试
# 其实不是很明白

  # Django中的单元测试
vi lists/tests.py 
python manage.py test

git status
vim s
git add lists/
git diff --staged
git commit -m "Add app for lists, with deliberately failing unit test"

  # Django中的MVC、URL 和视图函数
https://docs.djangoproject.com/en/1.11/faq/general/
# url-http进入,决定某个视图函数处理,视图函数处理请求,返回响应

# 测试内容:
# 能否解析 /,对应到某个函数
# 能否让视图返回一些HTML
vi lists/tests.py  
python manage.py test

# 内置函数 resolve
# home_page 定义的函数

  # 终于可以编写一些应用代码了
vi lists/views.py 
python manage.py test

# 阅读调用跟踪
# 先查看调试的最底端,错误本身
# 调试开头说明哪个测试失败了
# 接着是导致失败的示例代码

  # urls.py
# main urls.py 主urls
vi superlists/urls.py
# url(r'^$', 'superlists.views.home', name='home'),
url(r'^$', 'lists.views.home_page', name='home'),

vi lists/views.py
# home_page=None
def home_page():
    pass


# 排查历程:
# ImportError: cannot import name 'home_page'    #导入未定义函数 views
# raise Resolver404({'tried': tried, 'path': new_path})   #找不到url映射 urls
# Could not import superlists.views.home. Parent module superlists.views does not exist. #视图不存在urls
# Could not import lists.views.home. View does not exist in module lists.views    # 函数名错误
# Could not import lists.views.home_page. View is not callable    #home_page无法调用
# 第一个测试通过,排错结束

  # 为视图编写单元测试
    # 新的测试函数
vi lists/tests.py

# 创建了一个HttpRequest对象, 请求网页时,看到的就是这个对象
# HttpRequest对象传给home_page视图,得到响应
# 判断响应的.content属性,原始字节 html,/html,To-Do
# https://docs.djangoproject.com/en/1.7/topics/python3/
# 运行单元测试,改动少量代码
# 我决定装个新版,和网页一致 ok:

    # 填加参数
python manage.py test
# TypeError: home_page() takes 0 positional arguments but 1 was given
vi lists/views.py

    # 填加返回值
python manage.py test
# html = response.content.decode('utf8')
# AttributeError: 'NoneType' object has no attribute 'content'
vi lists/views.py

    # 返回html标签头部
#     self.assertTrue(html.startswith('<html>'))
# AssertionError: False is not true

    # 返回标题
# AssertionError: '<title>To-Do lists</title>' not found in '<html>'

    # 返回html尾部
# self.assertTrue(html.endswith('</html>'))
# AssertionError: False is not true

python manage.py test
# OK

python functional_tests.py
# AssertionError: Finish the test!

  # 编写这些测试有什么用
    # 编程就像从井里打水
    # 使用Selenium测试用户交互
python functional_tests.py

# 扩充功能测试
vi functional_tests.py
# find_element_by_tag_name  找不到报错
# find_elements_by_​tag_name    找不到反回空组
# find_element_by_id
# 还使用了keys类, 及any函数

python functional_tests.py
# Message: Unable to locate element: h1

    # 遵守“不测试常量”规则，使用模板解决这个问题
    # 使用模版重构
# https://refactoring.com/ 重构
python manage.py test
mkdir lists/templates
touch !$/home.html

vi lists/views.py
# from django.shortcuts import render
# HttpResponse 改成 render,输入参数,模板名

python functional_tests.py
# django.template.base.TemplateDoesNotExist: home.html

# 注册应用
vi superlists/settings.py
# 在INSTALLED_APPS 添加lists

python manage.py test
self.assertTrue(html.endswith('</html>'))
AssertionError: False is not true
# 转用模板后在响应尾引入的额外空行 增加strip()
# 理论上可以用 render_to_string 更新测试用例,但是失败了?


    # 关于重构
    # 接着修改首页
vi lists/templates/home.html
# 增加h1

# Message: Unable to locate element: [id="id_new_item"]
# 增加输入框

# AssertionError: '' != 'Enter a to-do item'
# 增加占位文字

# Message: Unable to locate element: [id="id_list_table"]
# 写成表格的形式

# any(row.text == '1: Buy peacock feathers' for row in rows) AssertionError: False is not true

vi functional_tests.py
# 修改功能测试,看到写入的备注,测试结束

    # 总结：TDD流程



保存用户输入
  # 编写表单，发送POST请求
# 提交表单
vi lists/templates/home.html
#<form method="POST">
#    <input name="item_text" id="id_new_item" />

# 面对面调试
python functional_tests.py
# 错误无法追踪,打印变量,改进错误,手动访问,延时

# 开放访问权限
# 我用的是headless的方式访问,打算修改配置让其他主机访问.
# 发现被django限制了, 开发限制的方法如下:
vi superlists/settings.py
# ALLOWED_HOSTS = ['*'], 测试环境使用,生产请输入准确ip

# CSRF错误
# 打开页面后看到了著名的403 Forbidden, CSRF认证失败
# http://www.cl.cam.ac.uk/~rja14/book.html

# 模板标签
vi lists/templates/home.html
  {% csrf_token %}
# 更新模板加入token标签

  # 在服务器中处理POST请求
# 新的单元测试
# 因为还没指定action属性,提交表单后默认返回之前渲染的页面"/"
# 需要修改视图函数,先写一个新的单元测试
vi lists/tests.py
  def test_can_save_a_POST_request()

# 想办法通过测试
vi lists/views.py
python manage.py test
# 修改判断再测试

  # 把Python变量传入模板中渲染
# 变量导入模板
vi lists/templates/home.html
#    <table id="id_list_table">
#        <tr><td>{{ new_item_text }}</td></tr>  
#    </table>

# 测试传入值
vi lists/tests.py
python manage.py test
AssertionError: No templates used to render the response

# 更新视图函数
vi lists/views.py
python manage.py test

# 回归
django.utils.datastructures.MultiValueDictKeyError: "'item_text'"
vi lists/views.py
  {
        'new_item_text': request.POST.get('item_text', ''),
    }
# https://docs.python.org/3/library/stdtypes.html#dict.get

python superlists/functional_tests.py
# AssertionError: False is not true : New to-do item did not appear in table

# 改进错误消息
# 上节报的错误看不出太多内容,更新一下
vi functional_tests.py
  f"New to-do item did not appear in table. Contents were:\n{table.text}" 
# 需要学习一下f的用法 格式字符串迭代?
# https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals

# 调整测试方法
python superlists/functional_tests.py
# AssertionError: False is not true : New to-do item did not appear in table.

vi functional_tests.py
# self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
AssertionError: '1: Buy peacock feathers' not found in ['Buy peacock feathers']

# 作弊
vi lists/templates/home.html
#    <tr><td>1: {{ new_item_text }}</td></tr>
# 修改模板,把1独立出来,骗过了测试

vi functional_tests.py
python superlists/functional_tests.py
# 增加第二条记录,测试报错

  # 事不过三，三则重构
# 重复三次的代码需要重构
vi superlists/functional_tests.py
# 增加函数check_for_row_in_list_table()
# 增加第二条记录的测试代码,使用新建测试函数测试清单显示
# 到此为止,发现需要持久化储存

#建一个新的测试类,记得导入Item模块
vi lists/tests.py
#class ItemModelTest(TestCase):
#    ...
# 创建对象,属性赋值,save(), .objects()方法, .count()方法
# 单元测试,集成测试,单元测试不涉及数据库?

python manage.py test
# ImportError: cannot import name 'Item'
vi lists/models.py
#建一个Item类,这次不写Item=None了?

python manage.py test
# AttributeError: 'Item' object has no attribute 'save'



  # Django ORM和第一个模型
#Object-Relational Mapper ORM

    # 第一个数据库迁移
    # 测试向前走得挺远
    # 添加新字段就要创建新迁移
  # 把POST请求中的数据存入数据库
  # 处理完POST请求后重定向
  # 在模板中渲染待办事项
  # 使用迁移创建生产数据库



